
# This script expects a path to a CSV file as its only argument
# The CSV file is generated by running the schtasks command to query
# scheduled tasks on a remote machine, e.g.:
# C:\Documents and Settings\serviceaccount>schtasks /query /s JOBSERVER-HOSTNAME /fo csv /v > C:\jobs.csv

use strict;
use warnings;

use English;
use File::Copy;
use File::Path;
use POSIX qw(strftime);
use Text::CSV_XS;

my $inputFile = $ARGV[0];

my $templateFile = ".\\scheduledTaskTemplate.xml";
my $outputDir = ".\\migratedTasks";

die "You must specify a valid input file as the only arg to the script\n"
    unless $inputFile && -f $inputFile;

mkpath($outputDir);

# WEAK!!
my %dayTranslations = (
                        'Mon' => 'Monday',
                        'Tue' => 'Tuesday',
                        'Wed' => 'Wednesday',
                        'Thu' => 'Thursday',
                        'Fri' => 'Friday',
                        'Sat' => 'Saturday',
                        'Sun' => 'Sunday',
                      );

my $createDate = strftime('%Y-%m-%dT%H:%M:%S.0000000', localtime());

my $csv = Text::CSV_XS->new();

$csv->column_names(qw(
                        HostName
                        TaskName
                        NextRunTime
                        Status
                        LastRunTime
                        LastResult
                        Creator
                        Schedule
                        TaskToRun
                        StartIn
                        Comment
                        ScheduledTaskState
                        ScheduledType
                        StartTime
                        StartDate
                        EndDate
                        Days
                        Months
                        RunAsUser
                        DeleteTaskIfNotRescheduled
                        StopTaskIfRunsXHoursAndXMins
                        RepeatEvery
                        RepeatUntilTime
                        RepeatUntilDuration
                        RepeatStopIfStillRunning
                        IdleTime
                        PowerManagement
                      ));

open(my $fh, $inputFile)
    or die "Could not open '" . $inputFile . "': " . $OS_ERROR . "\n";

while (my $row = $csv->getline_hr($fh))
{
    next if $row->{'ScheduledTaskState'} =~ /disabled/io;

    my $workingDir = $row->{'StartIn'};
       $workingDir = "C:\\pstools" if $row->{'StartIn'} =~ /n\/a/io;

    my $description = $row->{'Comment'};
       $description = '' if $row->{'Comment'} =~ /n\/a/io;

    my $command = $row->{'TaskToRun'};
    my $args = '';

    if ($command =~ /\.exe/)
    {
        my @commandParts = split(/\.exe/, $command);

        $command = $commandParts[0] . '.exe';
        $command =~ s/^\s*//o;
        $command =~ s/\s*$//o;

        $args = $commandParts[1];
        $args =~ s/^\s*//o;
        $args =~ s/\s*$//o;
    }

    my $startBoundary = '';
    my $schedule = '';
    my $today = strftime('%Y-%m-%d', localtime());

    if ($row->{'Schedule'} =~ /every day, /)
    {
        $row->{'Schedule'} =~ /^At (.+) every day/;

        my $runTime = $1;

        $runTime =~ /(\d+):(\d+) (A|P)M/;

        my $runTimeHour = $1;
        my $runTimeMinute = $2;
        my $runTimeAmOrPm = $3;

        if ($runTimeAmOrPm =~ /p/io && $runTimeHour != 12)
        {
            $runTimeHour += 12;
        }

        $startBoundary = $today . 'T' . $runTimeHour . ':' . $runTimeMinute . ':00';
        $schedule = "<ScheduleByDay>\n" .
                    "        <DaysInterval>1</DaysInterval>\n" .
                    '      </ScheduleByDay>';
    }
    elsif ($row->{'Schedule'} =~ /every week, /)
    {
        $row->{'Schedule'} =~ /^At (.+) every /;

        my $runTime = $1;

        $runTime =~ /(\d+):(\d+) (A|P)M/;

        my $runTimeHour = $1;
        my $runTimeMinute = $2;
        my $runTimeAmOrPm = $3;

        if ($runTimeAmOrPm =~ /p/io && $runTimeHour != 12)
        {
            $runTimeHour += 12;
        }

        $startBoundary = $today . 'T' . $runTimeHour . ':' . $runTimeMinute . ':00';

        $row->{'Schedule'} =~ /^At .+ every (.+) of every week/;

        my $oldJobDays = $1;

        my @jobDays = split /, /, $oldJobDays;

        $schedule = "<ScheduleByWeek>\n" .
                    "        <DaysOfWeek>\n";

        foreach my $day (@jobDays)
        {
            $schedule .= '          <' . $dayTranslations{$day} . " />\n";
        }

        $schedule .= "        </DaysOfWeek>\n" .
                     "        <WeeksInterval>1</WeeksInterval>\n" .
                     "      </ScheduleByWeek>";
    }

    my $newTaskName = $row->{'TaskName'};

    if ($newTaskName =~ /^restart (nt(s|c|e|d)-(ctx|sql(d|p|q))?\d+)$/io)
    {
        $newTaskName = uc( $1 ) . ' reboot';
    }
    elsif ($newTaskName =~ /^restart (.+) on (nts-\d+)$/io)
    {
        $newTaskName = uc( $2 ) . ' restart ' . $1;
    }

    my $newTaskFileName = $newTaskName . '.xml';

    copy($templateFile, $newTaskFileName);

    open(TEMPLATE, $templateFile);

    my @templateLines = <TEMPLATE>;

    close(TEMPLATE);

    my %replacements = (
                         'CreateDate'    => $createDate,
                         'Comment'       => $description,
                         'StartBoundary' => $startBoundary,
                         'Schedule'      => $schedule,
                         'RunAsUser'     => $row->{ 'RunAsUser' },
                         'Command'       => $command,
                         'Args'          => $args,
                         'StartIn'       => $workingDir,
                       );

    my @newTaskFileLines = ();

    foreach my $templateLine (@templateLines)
    {
        if ($templateLine =~ /\{(\w+)\}/)
        {
            my $key = $1;
            my $value = $replacements{$key};

            $templateLine =~ s/\{$key\}/$value/;
        }

        push @newTaskFileLines, $templateLine;
    }

    open(NEW_FILE, '>' . $outputDir . "\\" . $newTaskFileName);

    map { print NEW_FILE $_; } @newTaskFileLines;

    close(NEW_FILE);
}

close($fh);


__END__
